# 微信小程序

- 微信小程序是一个双线程模型，由**渲染层线程和逻辑层线程**来**并行**工作
- 渲染层由多个webView线程组成，一个页面拥有一个webView线程，逻辑层只有一个js线程，js文件会按顺序合并成一个App Service.js文件
- 逻辑层和渲染层的通信需要通过**微信客户端（native）**

> 微信小程序不能直接去操作DOM



引出一个问题：**为什么要选双线程模型**

- 为了快，双线程并行，js线程和渲染线程并行运行，优化渲染速率（相比传统web应用而言）
- 为了安全和管控，规定js不能操作DOM，保证数据的安全性和隐秘性。比如说open-data组件展示微信开放的数据，但里面有些隐私数据，不希望js直接读取到。



## 双线程带来的问题？

​	**时延问题**，渲染层和逻辑层的通信是需要通过微信客户端的，这也说明当逻辑层数据改变时，渲染层对应的UI还没修改，所以大多数小程序API设计成了异步。



# 小程序兼容问题

只需考虑三种

1. IOS微信客户端
2. 安卓微信客户端
3. 小程序开发者工具

| 运行环境         | 逻辑层             | 渲染层         |
| ---------------- | ------------------ | -------------- |
| IOS              | JavascriptCore     | WKWebView      |
| 安卓             | X5 JSCore          | X5浏览器       |
| 小程序开发者工具 | nwjs（node-wekit） | Chrome WebView |



# 小程序技术选型

遵循**快（渲染快、加载快）**

一般来说，渲染界面的技术有三种

- 纯客户端技术
- 纯web技术
- 两种混合，称为hybrid技术



​	首先，采用纯客户端技术，小程序的代码和微信的代码就应该一起编包，跟随微信一起进行版本的迭代。这种开发节奏显然是不行的。

​	其次，采用纯web技术的话，虽然开发节奏会变快，但其js线程和渲染线程是互斥的，存在性能问题。

​	最后，Hybrid技术，比如**react-native**，js脚本负责逻辑任务，渲染任务交给客户端，但存在css样式太少以及一些性能问题。小程序现在采用的**js-sdk**的hybird技术，即界面主要由web技术渲染，提供一些接口以供进行客户端渲染，内置组件中一些复杂的组件就采取客户端渲染。



# 原生组件

微信小程序内置组件里有一些由客户端渲染的组件，称为**原生组件**。

## 运行机制

​	原生组件在webView线程的任务是只需渲染一个占位元素，之后通知客户端在这占位元素上叠一层对应的原生界面，这个原生界面相比其他DOM节点，层级更高。



## 优点

- 渲染性能提升，绕过setData、数据通信和重渲染，通过context进行修改数据，然后交给客户端中转直接交给组件。
- 减轻webView线程的压力，交给更高效的客户端进行原生处理



## 限制

- 脱离了webview渲染
- 一些css样式不能应用于原生组件
  - 不能在父元素运用`overflow：hidden`去剪切原生组件显示的区域
- 原生组件因为其高层级，使得其他组件无法覆盖其上面， 考虑使用`cover-view、cover-image`原生组件来解决。



## 常见的原生组件

- map - 地图
- video - 视频
- canvas - 画布
- picker - 弹出式选择器



# 微信登录

![img](https://res.wx.qq.com/wxdoc/dist/assets/img/api-login.2fcc9f35.jpg)

1. 小程序通过wx.login向微信服务器获取一个临时code作为身份凭证，有效期为5分钟。
2. 小程序将code发送到开发者服务器
3. 开发者服务器通过将**code、appID、appSecret**发送给微信服务器，请求用户信息，获取一个openID（用户唯一标识）和session_key（会话密钥）
4. 通过自定义登录状态，与openID、session_key关联，将自定义登录状态（token/sessionID）返回给小程序
5. 小程序之后发送请求带上此自定义登陆状态，用于开发者服务器验证用户身份
