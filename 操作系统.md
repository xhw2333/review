# 概念

操作系统是管理计算机硬件和软件资源的应用程序，处理文件管理、IO操作、内存管理、进程管理、设备管理

计算机由CPU、内存、外部设备组成，之间通过总线连接。

CPU主要由控制器、运算器、寄存器组成。控制器负责指令的读取和调度，运算器负责指令的运算，寄存器负责数据的存储

![image-20220226152958992](C:\Users\小浩王\AppData\Roaming\Typora\typora-user-images\image-20220226152958992.png)



用户态：用户态运行的进程可以直接读取用户程序的数据

内核态：内核态运行的进程或程序可以访问系统的任何资源，不受限制

**用户态转内核态**

- 系统调用
  - 文件管理
  - 内存管理
  - 设备管理
  - 进程控制
  - 进程通信
- 内中断，也称为异常
  - 程序非法操作
  - 地址越界
  - 浮点溢出

- 外围设备的中断

> 系统调用是用户进程主动发起的，后两种是被动



# 进程、线程、协程



## 进程（process）

- 资源拥有的基本单位
- 一个程序会创建一个或多个进程
- 进程状态有就绪、阻塞、运行，创建、终止

**进程状态转换**

![image-20220224221614696](C:\Users\小浩王\AppData\Roaming\Typora\typora-user-images\image-20220224221614696.png)

## 线程（thread）

- 操作系统分配和调度的基本单位
- 一个进程可以有多个线程，至少有一个主线程，子线程由主线程创建，线程共享着此进程的内存空间、资源
- 线程切换需要在内核态进行

## 协程（coroutine）

- 用户态的轻量级线程，叫做用户空间线程
- 一个线程可以有多个协程
- 开销更小，协程切换是在用户态时完成的



## 进程控制块

进程控制块（PCB），描述者进程的基本信息以及状态

> 问到进程是怎么创建和撤销的，都需说到PCB

- 进程描述信息
  - 进程标识符
  - 用户标识符
- 进程控制信息
  - 进程状态
  - 进程优先级
- 资源分配清单
  - 程序段指针：当前进程的程序在内存的什么地方
  - 数据段指针：当前进程的数据在内存的什么地方
  - 键盘
  - 鼠标
- 处理机相关信息
  - 各个寄存器存储的值（寄存器负责数据的存储）



## 进程通信

一个进程不能直接访问另一个进程的内存地址空间，因为各进程的地址空间相互独立。

**进程通信的方式**

- 共享存储
  - 操作系统提供一个**内存空间**供彼此进程可以访问
  - 进程对共享空间的访问都是**互斥**的，所以需要操作系统提供**同步互斥工具**（PV操作的**信号量操作**）
  - 数据形式、存放位置由进程控制
  
  ![image-20220224221643878](C:\Users\小浩王\AppData\Roaming\Typora\typora-user-images\image-20220224221643878.png)
  
- 管道

  - 只支持**半双工通信**，如果要**双向通信，只能再创建一个管道**
  - 管道数据以**字符流**形式写入管道
  - 各进程访问管道是互斥的

  ![image-20220224224840649](C:\Users\小浩王\AppData\Roaming\Typora\typora-user-images\image-20220224224840649.png)

- 消息队列

  - 进程间的数据交换以“格式化消息”为单位，靠操作系统的“发送消息/接收消息”两个原语来进行数据交互
    - 消息的结构为消息头、消息体
    - 消息头包括发送进程ID、接收进程ID、消息类型、长度等格式化信息
    - 消息体即要交互的数据

  - 分为直接通信和间接通信
    - 直接通信：直接挂载到接收进程的消息缓冲队列
    - 间接通信：需要依靠一个中间实体（信箱），存储“格式化消息”
  - 读进程可以**根据消息类型有选择**地读取消息
  - 不适合频繁通信且数据量大的情况

  ![image-20220224231459785](C:\Users\小浩王\AppData\Roaming\Typora\typora-user-images\image-20220224231459785.png)

- 套接字

  - 用于不同机器两个进程间的通信，比如：socket




## 进程同步

控制进程按一定顺序进行

- 临界区，访问临界资源的称为**临界区**
- 信号量（PV操作）
- 管程



## 关于进程、线程切换问题

每个进程都有属于自己的**虚拟内存**，进程切换比线程切换的开销大，进程在切换时需要涉及到虚拟内存的切换，还会涉及CPU环境，各种状态的保存以及新进程状态的设置等等，线程切换只需设置和修改少量寄存器值即可。

> 进程上下文：进程的地址空间，堆栈内容，寄存器内容



## 进程调度

批处理系统

- 先来先服务（FCFS）
- 短作业优先（SJF）
- 最短剩余时间优先（SRTN）
- 高响应比优先

交互式系统

- 时间片轮转
- 优先级调度
- 多级反馈队列



# 死锁

​	死锁就是多个进程在运行期间因**争夺资源**而陷入的一种僵局，当进程处于这种僵持状态，如果没有外力推动，它们将无法向前推进。

## 产生死锁原因

- 竞争资源
  - 竞争不可剥夺资源
  - 竞争临时资源
- 进程间推进顺序非法，典型例子：银行家算法



## 产生死锁的必要条件

- 互斥条件：一段时间资源只允许一进程使用
- 请求和保持条件：当进程因请求资源阻塞时，保持已有资源不释放
- 不剥夺条件：进程运行中不允许被剥夺，只能由自己释放
- 环路等待条件：当发生死锁，会形成资源的环形链，进程等待另一进程释放资源



## 预防死锁原因

- 一次性分配资源，（破坏保持条件）
- 有一个资源得不到分配，也不给这个进程分配其他资源（破坏请求和保持条件）
- 可剥夺资源（破坏不可剥夺条件）
- 资源有序分配法，按序号递增分配资源，释放资源反序着来（破坏环路等待条件）

### 银行家算法

原理：判断进程申请的资源是否会使系统进入**不安全的状态**，会的话则重新分配



## 死锁例子

**生产者消费者模型**，生产者要生成一个产品，先对临界区上锁，此时检测临界区已满，需等待消费者消费一个产品，但此时临界区已被生产者上锁，所以消费者无法对临界区进行操作，此时造成死锁



# 内存管理

​	内存是计算机其他硬件设备与CPU沟通的桥梁，程序执行都需要在内存才能被CPU处理。

> 虚拟内存：利用部分磁盘充当内存

内存分配分为**连续分配存储和不连续分配存储**

## 栈内存和堆内存

栈内存

- 存储变量和方法调用，基础类型和引用类型的地址
- 归属于单个线程，每个线程都会一个栈内存，其存储的变量只在归属的线程中可见
- **内存空间远小于堆内存**



堆内存

- 存储引用类型，即对象
- 堆内存中的对象对所有线程可见，可被所有线程访问。



## 连续分配存储管理

### 固定分区

内存划分为固定大小的分区

缺点明显：内碎片造成浪费

### 动态分区

通过系统调用动态分配改变分区的大小。

> 解决了内碎片问题，但引入了外碎片

常见算法

- 最先适配，从头开始找，第一个符合条件的就分配
- 下次适配，从上次分配的分区开始找，第一个符合的就分配
- 最佳适配，从头开始找，找到最适合（相差最小）的分区就分配
- 最坏适配，从头开始找，找到最大的空闲分区进行分配。



## 不连续分配存储管理

- 分页式管理
  - 将程序的地址空间分为相同大小的页进行管理
  - 一个页表存储在页表寄存器中，记录每个页面的地址映射情况（页号，物理块）
  - 虚拟地址由页号、偏移量组成
  
  ![image-20220226212751850](C:\Users\小浩王\AppData\Roaming\Typora\typora-user-images\image-20220226212751850.png)
  
  > 此处内存需访问两次（访问页表、访问值），所以引出快表（存储在cache）
  
- 分段式管理

  - 程序的地址空间划分为多个拥有独立空间的段，例如：main函数等等，
  - 段表存储在段表寄存器中，记录地址映射情况（段号，起始物理地址）
  - 虚拟地址由段号、段内地址组成

  ![image-20220226213438898](C:\Users\小浩王\AppData\Roaming\Typora\typora-user-images\image-20220226213438898.png)

- 段页式管理

  - 程序的地址空间划分成多个拥有独立空间的段，每段再划分成相同大小的页。




### 分页和分段

- **共同**
  - 都是不连续分配内存的，每个页和每个段的内存都是连续的
  - 都是为了提高内存利用率，减少内碎片
- **区别**
  - 分页式管理的页面大小固定，由操作系统决定，分段式管理的段不固定，由用户程序决定
  - 分段式管理的段是有意义的，可能是代码段，程序段；分页式管理只是为了满足操作系统的要求
  - 分页式内存利用率高，不会产生内部碎片；分段式如果段过长，不太方便分配内存空间，会产生外部碎片



### 页面置换算法

当发生缺页中断，即访问的页面不在内存，需要操作其调入内存来进行访问。

常见算法

- OPT，最佳：最长时间未使用
- LRU，最近最久未使用
- FIFO，先进先出
- CLOCK算法，最近未使用算法，每页设置一个标志位，将内存中所有页面通过链接指针链接成循环队列，当某个页面被访问，设置为1，被淘汰时，检查标志位是否为1，是则换出，否则设置为0，再检查下一个页面。



# 文件管理

## 文件描述符

- 文件描述符本身是一个索引值
- 内核使用文件描述符去访问文件
- 每当创建或打开一个文件，内核会返回一个文件描述符
- 读写文件也需要文件描述符去访问待读写文件
- 不同文件描述符也会指向同一个文件

## 磁盘调度

- 先来先服务
- 最短寻道优先
- 扫描
- 循环扫描

